"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[5210],{979(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"architecture/execution-authority-vs-agent-memory","title":"Execution Authority vs Agent Memory vs Runtime","description":"This document explains the strict separation of responsibilities enforced by Gantral.","source":"@site/../docs/architecture/execution-authority-vs-agent-memory.md","sourceDirName":"architecture","slug":"/architecture/execution-authority-vs-agent-memory","permalink":"/architecture/execution-authority-vs-agent-memory","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Execution Authority vs Agent Memory vs Runtime"},"sidebar":"docsSidebar","previous":{"title":"Authority State Machine","permalink":"/architecture/authority-state-machine"},"next":{"title":"Implementation Guide","permalink":"/architecture/implementation-guide"}}');var t=i(4848),s=i(8453);const l={title:"Execution Authority vs Agent Memory vs Runtime"},o="Execution Authority vs Agent Memory vs Runtime",a={},c=[{value:"High-Level Responsibility Split",id:"high-level-responsibility-split",level:2},{value:"Single-Page Architecture Diagram",id:"single-page-architecture-diagram",level:2},{value:"How to Read This Diagram",id:"how-to-read-this-diagram",level:2},{value:"1. Gantral = Execution Authority",id:"1-gantral--execution-authority",level:3},{value:"2. Deterministic Runtime = Ordering, Time, Replay",id:"2-deterministic-runtime--ordering-time-replay",level:3},{value:"3. Agent Framework = Reasoning and Memory",id:"3-agent-framework--reasoning-and-memory",level:3},{value:"4. Runners = Execution Boundary",id:"4-runners--execution-boundary",level:3},{value:"Why This Separation Matters",id:"why-this-separation-matters",level:2},{value:"One-Line Mental Model",id:"one-line-mental-model",level:2}];function h(e){const n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"execution-authority-vs-agent-memory-vs-runtime",children:"Execution Authority vs Agent Memory vs Runtime"})}),"\n",(0,t.jsxs)(n.p,{children:["This document explains the ",(0,t.jsx)(n.strong,{children:"strict separation of responsibilities"})," enforced by Gantral."]}),"\n",(0,t.jsx)(n.p,{children:"It answers one question unambiguously:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Who owns which state, and why a deterministic runtime (e.g. Temporal) is still required even when agents manage their own memory."})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This separation is foundational to ",(0,t.jsx)(n.strong,{children:"verifiability, replay, and audit correctness"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"high-level-responsibility-split",children:"High-Level Responsibility Split"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Authority"})," \u2192 ",(0,t.jsx)(n.em,{children:"Gantral"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Runtime"})," \u2192 ",(0,t.jsx)(n.em,{children:"Deterministic Workflow Engine (e.g. Temporal)"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Agent Memory & Reasoning"})," \u2192 ",(0,t.jsx)(n.em,{children:"Agent Frameworks (CrewAI, LangGraph, etc.)"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Each layer is necessary.",(0,t.jsx)(n.br,{}),"\n","No layer may subsume the responsibilities of another."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"single-page-architecture-diagram",children:"Single-Page Architecture Diagram"}),"\n",(0,t.jsx)(n.mermaid,{value:'flowchart TB\n\n  %% ===== External Triggers =====\n  EXT["External Trigger<br/>Event / Schedule / API"]\n\n  %% ===== Gantral =====\n  subgraph G["Gantral \u2014 Execution Authority"]\n    G1["Authority State Machine<br/>RUNNING / WAITING_FOR_HUMAN / ..."]\n    G2["Human Authority Enforcement<br/>APPROVE / REJECT / OVERRIDE"]\n    G3["Policy Evaluation Interface<br/>Transition Guards (Advisory)"]\n    G4["Authority Record Store<br/>Immutable Commitment Artifacts"]\n  end\n\n  %% ===== Runtime =====\n  subgraph T["Deterministic Runtime (Temporal)"]\n    T1["Workflow Orchestration"]\n    T2["Durable Timers & Signals"]\n    T3["Deterministic Replay<br/>Authority Decisions Only"]\n  end\n\n  %% ===== Runners =====\n  subgraph R["Runners (Team-Owned Infrastructure)"]\n    R1["Agent Process Launcher"]\n    R2["Lifecycle Signals<br/>COMPLETED / FAILED / SUSPENDED"]\n  end\n\n  %% ===== Agent Framework =====\n  subgraph A["Agent Framework"]\n    A1["Agent Reasoning & Planning"]\n    A2["Agent Memory<br/>Conversation / Tool State"]\n    A3["Native Persistence<br/>Checkpoint Store (DB / S3)"]\n  end\n\n  %% ===== Flows =====\n  EXT --\x3e G1\n\n  G1 --\x3e T1\n  G2 --\x3e T2\n  G3 --\x3e T1\n\n  T1 --\x3e R1\n  R1 --\x3e A1\n\n  A1 --\x3e A2\n  A2 --\x3e A3\n\n  %% Suspend / Resume Flow\n  A1 --\x3e|Requires Authority| R2\n  R2 --\x3e|SUSPENDED| T2\n  T2 --\x3e|Approval Signal| R1\n\n  %% Completion Flow\n  A1 --\x3e|Completed / Error| R2\n  R2 --\x3e T1\n\n  %% Audit\n  G1 --\x3e G4\n  G2 --\x3e G4\n  T3 --\x3e G4'}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"how-to-read-this-diagram",children:"How to Read This Diagram"}),"\n",(0,t.jsx)(n.h3,{id:"1-gantral--execution-authority",children:"1. Gantral = Execution Authority"}),"\n",(0,t.jsxs)(n.p,{children:["Gantral owns ",(0,t.jsx)(n.strong,{children:"execution authority as state"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"It is responsible for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"defining when execution may proceed"}),"\n",(0,t.jsx)(n.li,{children:"enforcing Human-in-the-Loop (HITL)"}),"\n",(0,t.jsx)(n.li,{children:"recording authority decisions immutably"}),"\n",(0,t.jsx)(n.li,{children:"emitting commitment artifacts atomically with authority transitions"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Gantral explicitly does ",(0,t.jsx)(n.strong,{children:"not"})," see or manage:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"agent memory"}),"\n",(0,t.jsx)(n.li,{children:"prompts"}),"\n",(0,t.jsx)(n.li,{children:"tool payloads"}),"\n",(0,t.jsx)(n.li,{children:"agent reasoning traces"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Gantral governs ",(0,t.jsx)(n.strong,{children:"permission"}),", not cognition."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"2-deterministic-runtime--ordering-time-replay",children:"2. Deterministic Runtime = Ordering, Time, Replay"}),"\n",(0,t.jsx)(n.p,{children:"A deterministic workflow runtime (e.g. Temporal) is required even when agents manage their own memory."}),"\n",(0,t.jsx)(n.p,{children:"The runtime owns:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ordering of execution steps"}),"\n",(0,t.jsx)(n.li,{children:"durable timers and waits"}),"\n",(0,t.jsx)(n.li,{children:"retries and escalation timing"}),"\n",(0,t.jsxs)(n.li,{children:["deterministic replay of ",(0,t.jsx)(n.strong,{children:"authority decisions"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The runtime does ",(0,t.jsx)(n.strong,{children:"not"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"reason"}),"\n",(0,t.jsx)(n.li,{children:"evaluate policy"}),"\n",(0,t.jsx)(n.li,{children:"grant authority"}),"\n",(0,t.jsx)(n.li,{children:"persist agent memory"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Replay re-executes workflow logic using recorded authority history.\nIt never reconstructs agent cognition."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"3-agent-framework--reasoning-and-memory",children:"3. Agent Framework = Reasoning and Memory"}),"\n",(0,t.jsx)(n.p,{children:"Agent frameworks own:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"reasoning and planning"}),"\n",(0,t.jsx)(n.li,{children:"tool invocation"}),"\n",(0,t.jsx)(n.li,{children:"internal state and memory"}),"\n",(0,t.jsx)(n.li,{children:"persistence of agent checkpoints"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Agents may safely:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"checkpoint state"}),"\n",(0,t.jsx)(n.li,{children:"exit during long waits"}),"\n",(0,t.jsx)(n.li,{children:"resume later in a new process"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If an agent framework does ",(0,t.jsx)(n.strong,{children:"not"})," support native persistence:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["the agent ",(0,t.jsx)(n.strong,{children:"must be split"})," into pre-approval and post-approval stages"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Gantral never serializes or inspects agent memory."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"4-runners--execution-boundary",children:"4. Runners = Execution Boundary"}),"\n",(0,t.jsx)(n.p,{children:"Runners are the execution edge."}),"\n",(0,t.jsx)(n.p,{children:"They:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"launch agent processes"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"detect lifecycle outcomes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"COMPLETED"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"FAILED"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"SUSPENDED"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"translate outcomes into Gantral execution events"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Runners never:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"evaluate policy"}),"\n",(0,t.jsx)(n.li,{children:"make authority decisions"}),"\n",(0,t.jsx)(n.li,{children:"infer approval"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"They are strictly mechanical."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"why-this-separation-matters",children:"Why This Separation Matters"}),"\n",(0,t.jsx)(n.p,{children:"This architecture enables:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verifiable audit"})," \u2014 authority can be replayed without agent memory"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fail-closed behavior"})," \u2014 execution stops if authority cannot be enforced"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost efficiency"})," \u2014 no compute during long human approvals"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Framework freedom"})," \u2014 any agent system may be used"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Regulator confidence"})," \u2014 explicit ownership of decisions"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Collapsing these layers breaks determinism and auditability."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"one-line-mental-model",children:"One-Line Mental Model"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Gantral decides.\nThe runtime remembers.\nAgents think."})}),"\n",(0,t.jsx)(n.hr,{})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>o});var r=i(6540);const t={},s=r.createContext(t);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);